import { Plus, Trash2, Loader2 } from "lucide-react";
import {
  SegmentCondition,
  SegmentConditionGroup,
  SEGMENT_FIELDS,
  PROFILE_360_FIELDS,
  OPERATOR_LABELS,
} from "../types/segment";
import ListUpload from "./ListUpload";
import { color, tw, button } from "../../../shared/utils/utils";
import HeadlessSelect from "../../../shared/components/ui/HeadlessSelect";
import { useSegmentationFields } from "../hooks/useSegmentationFields";

interface SegmentConditionsBuilderProps {
  conditions: SegmentConditionGroup[];
  onChange: (conditions: SegmentConditionGroup[]) => void;
}

export default function SegmentConditionsBuilder({
  conditions,
  onChange,
}: SegmentConditionsBuilderProps) {
  const generateId = () => Math.random().toString(36).substr(2, 9);

  // Load segmentation fields from backend
  const {
    categories,
    allFields,
    isLoading: isLoadingFields,
    error: fieldsError,
    getFieldById,
    getFieldByValue,
    getOperatorsForField,
    getFieldType: getBackendFieldType,
  } = useSegmentationFields();

  const addConditionGroup = () => {
    // Use first field from backend if available, fallback to hardcoded
    const firstField = allFields.length > 0 ? allFields[0] : null;
    const defaultFieldValue = firstField
      ? firstField.field_value
      : SEGMENT_FIELDS[0].key;
    const defaultFieldId = firstField ? firstField.id : undefined;
    const defaultOperatorId = firstField?.operators[0]?.id;

    const newGroup: SegmentConditionGroup = {
      id: generateId(),
      operator: "AND",
      groupOperator: "AND", // Default operator between groups
      conditions: [
        {
          id: generateId(),
          conditionType: "360_profile", // Default to 360 profile
          category: categories.length > 0 ? categories[0].id : undefined,
          field: defaultFieldValue,
          field_id: defaultFieldId,
          operator: "equals",
          operator_id: defaultOperatorId,
          value: "",
          type: "string",
        },
      ],
    };
    onChange([...conditions, newGroup]);
  };

  const removeConditionGroup = (groupId: string) => {
    onChange(conditions.filter((group) => group.id !== groupId));
  };

  const updateConditionGroup = (
    groupId: string,
    updates: Partial<SegmentConditionGroup>
  ) => {
    onChange(
      conditions.map((group) =>
        group.id === groupId ? { ...group, ...updates } : group
      )
    );
  };

  const addCondition = (groupId: string) => {
    // Use first field from backend if available, fallback to hardcoded
    const firstField = allFields.length > 0 ? allFields[0] : null;
    const defaultFieldValue = firstField
      ? firstField.field_value
      : SEGMENT_FIELDS[0].key;
    const defaultFieldId = firstField ? firstField.id : undefined;
    const defaultOperatorId = firstField?.operators[0]?.id;

    const newCondition: SegmentCondition = {
      id: generateId(),
      conditionType: "360_profile", // Default to 360 profile
      category: categories.length > 0 ? categories[0].id : undefined,
      field: defaultFieldValue,
      field_id: defaultFieldId,
      operator: "equals",
      operator_id: defaultOperatorId,
      value: "",
      type: "string",
    };

    onChange(
      conditions.map((group) =>
        group.id === groupId
          ? { ...group, conditions: [...group.conditions, newCondition] }
          : group
      )
    );
  };

  const removeCondition = (groupId: string, conditionId: string) => {
    onChange(
      conditions.map((group) =>
        group.id === groupId
          ? {
              ...group,
              conditions: group.conditions.filter((c) => c.id !== conditionId),
            }
          : group
      )
    );
  };

  const updateCondition = (
    groupId: string,
    conditionId: string,
    updates: Partial<SegmentCondition>
  ) => {
    onChange(
      conditions.map((group) =>
        group.id === groupId
          ? {
              ...group,
              conditions: group.conditions.map((condition) =>
                condition.id === conditionId
                  ? { ...condition, ...updates }
                  : condition
              ),
            }
          : group
      )
    );
  };

  const getFieldType = (fieldKey: string, isProfile360 = false) => {
    // Try to get field from backend first
    if (!isProfile360 && allFields.length > 0) {
      const backendField = getFieldByValue(fieldKey);
      if (backendField) {
        // Map backend field types to our internal types
        switch (backendField.field_type) {
          case "numeric":
            return "number";
          case "text":
            return "string";
          case "boolean":
            return "boolean";
          default:
            return "string";
        }
      }
    }

    // Fallback to hardcoded fields for 360 profiles or if backend fields not loaded
    const fields = isProfile360 ? PROFILE_360_FIELDS : SEGMENT_FIELDS;
    const field = fields.find((f) => f.key === fieldKey);
    return field?.type || "string";
  };

  const getAvailableOperators = (fieldKey: string, isProfile360 = false) => {
    // Try to get operators from backend first
    if (!isProfile360 && allFields.length > 0) {
      const backendField = getFieldByValue(fieldKey);
      if (backendField && backendField.operators.length > 0) {
        // Map backend operators to our internal operator labels
        return backendField.operators.map((op) => {
          // Map backend symbols to our internal operator keys
          const symbolMap: Record<string, string> = {
            "=": "equals",
            "!=": "not_equals",
            ">": "greater_than",
            "<": "less_than",
            IN: "in",
            "NOT IN": "not_in",
            LIKE: "contains",
            "NOT LIKE": "not_contains",
          };
          return symbolMap[op.symbol] || op.label;
        });
      }
    }

    // Fallback to hardcoded operators
    const fields = isProfile360 ? PROFILE_360_FIELDS : SEGMENT_FIELDS;
    const field = fields.find((f) => f.key === fieldKey);
    return field?.operators || ["equals"];
  };

  const renderConditionValue = (
    groupId: string,
    condition: SegmentCondition,
    isProfile360 = false
  ) => {
    const fieldType = getFieldType(condition.field, isProfile360);
    const updateFunction = isProfile360
      ? updateProfileCondition
      : updateCondition;

    // Get backend field to check for dropdown component type
    const backendField = !isProfile360
      ? getFieldByValue(condition.field)
      : null;
    const isDropdown = backendField?.ui?.component_type === "dropdown";
    const isMultiSelect = backendField?.ui?.is_multi_select || false;
    const distinctValues = backendField?.validation?.distinct_values || [];

    // If field has dropdown component type with distinct values, render dropdown
    if (isDropdown && distinctValues.length > 0) {
      if (
        isMultiSelect ||
        condition.operator === "in" ||
        condition.operator === "not_in"
      ) {
        // Multi-select dropdown - display as checkboxes
        const selectedValues = Array.isArray(condition.value)
          ? condition.value.map((v) => String(v))
          : condition.value
          ? [String(condition.value)]
          : [];

        return (
          <div className="min-w-[200px]">
            <div className="border border-gray-300 rounded-md p-2 max-h-40 overflow-y-auto bg-white">
              {distinctValues.map((val, idx) => {
                const isChecked = selectedValues.includes(val);
                return (
                  <label
                    key={idx}
                    className="flex items-center space-x-2 px-2 py-1 hover:bg-gray-50 rounded cursor-pointer"
                  >
                    <input
                      type="checkbox"
                      checked={isChecked}
                      onChange={(e) => {
                        let newValues: string[];
                        if (e.target.checked) {
                          newValues = [...selectedValues, val];
                        } else {
                          newValues = selectedValues.filter((v) => v !== val);
                        }
                        updateFunction(groupId, condition.id, {
                          value:
                            newValues.length > 1
                              ? newValues
                              : newValues[0] || "",
                          type: newValues.length > 1 ? "array" : "string",
                        });
                      }}
                      className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="text-sm text-gray-700">{val}</span>
                  </label>
                );
              })}
            </div>
            <p className="text-xs text-gray-500 mt-1">
              {selectedValues.length} value(s) selected
            </p>
          </div>
        );
      } else {
        // Single-select dropdown
        return (
          <div className="min-w-[200px]">
            <HeadlessSelect
              options={distinctValues.map((val) => ({
                value: val,
                label: val,
              }))}
              value={condition.value as string}
              onChange={(value) => {
                updateFunction(groupId, condition.id, {
                  value: value as string,
                  type: "string",
                });
              }}
              placeholder="Select value"
              className="text-sm"
            />
          </div>
        );
      }
    }

    // Fallback to original input logic for non-dropdown fields
    if (condition.operator === "in" || condition.operator === "not_in") {
      return (
        <input
          type="text"
          value={
            Array.isArray(condition.value)
              ? condition.value.join(", ")
              : condition.value
          }
          onChange={(e) => {
            const values = e.target.value
              .split(",")
              .map((v) => v.trim())
              .filter((v) => v);
            updateFunction(groupId, condition.id, {
              value: values,
              type: "array",
            });
          }}
          placeholder="Enter values separated by commas"
          className={`px-3 py-2 border border-[${tw.borderDefault}] rounded-md focus:outline-none text-sm`}
        />
      );
    }

    return (
      <input
        type={fieldType === "number" ? "number" : "text"}
        value={condition.value as string | number}
        onChange={(e) => {
          const value =
            fieldType === "number"
              ? parseFloat(e.target.value) || 0
              : e.target.value;
          updateFunction(groupId, condition.id, { value, type: fieldType });
        }}
        placeholder="Enter value"
        className={`px-3 py-2 border border-[${tw.borderDefault}] rounded-md focus:outline-none text-sm`}
      />
    );
  };

  const addProfileCondition = (groupId: string) => {
    const newCondition: SegmentCondition = {
      id: generateId(),
      field: PROFILE_360_FIELDS[0].key,
      operator: "equals",
      value: "",
      type: "string",
    };

    onChange(
      conditions.map((group) =>
        group.id === groupId
          ? {
              ...group,
              profileConditions: [
                ...(group.profileConditions || []),
                newCondition,
              ],
            }
          : group
      )
    );
  };

  const removeProfileCondition = (groupId: string, conditionId: string) => {
    onChange(
      conditions.map((group) =>
        group.id === groupId
          ? {
              ...group,
              profileConditions: (group.profileConditions || []).filter(
                (c) => c.id !== conditionId
              ),
            }
          : group
      )
    );
  };

  const updateProfileCondition = (
    groupId: string,
    conditionId: string,
    updates: Partial<SegmentCondition>
  ) => {
    onChange(
      conditions.map((group) =>
        group.id === groupId
          ? {
              ...group,
              profileConditions: (group.profileConditions || []).map(
                (condition) =>
                  condition.id === conditionId
                    ? { ...condition, ...updates }
                    : condition
              ),
            }
          : group
      )
    );
  };

  // Show loading state while fields are being fetched
  if (isLoadingFields) {
    return (
      <div className="flex items-center justify-center py-8">
        <Loader2 className="w-6 h-6 animate-spin text-gray-400 mr-2" />
        <p className="text-gray-500">Loading field configuration...</p>
      </div>
    );
  }

  // Show error if fields failed to load
  if (fieldsError) {
    return (
      <div className="text-center py-8">
        <p className="text-red-600 mb-2">Failed to load field configuration</p>
        <p className="text-sm text-gray-500">{fieldsError}</p>
      </div>
    );
  }

  if (conditions.length === 0) {
    return (
      <div className="text-center py-8">
        <p className="text-gray-500 mb-4">No conditions defined yet</p>
        <button
          type="button"
          onClick={addConditionGroup}
          className="inline-flex items-center px-4 py-2 text-sm text-white rounded-md transition-colors"
          style={{
            backgroundColor: color.primary.action,
          }}
        >
          <Plus className="w-4 h-4 mr-2" />
          Add Condition Group
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {conditions.map((group, groupIndex) => (
        <div
          key={group.id}
          className="border border-gray-200 rounded-md p-4 bg-gray-50"
        >
          {/* Group Header */}
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center space-x-3">
              {/* Operator Between Groups - Make it selectable */}
              {groupIndex > 0 && (
                <div className="w-20">
                  <HeadlessSelect
                    options={[
                      { value: "AND", label: "AND" },
                      { value: "OR", label: "OR" },
                    ]}
                    value={conditions[groupIndex - 1].groupOperator || "AND"}
                    onChange={(value) =>
                      updateConditionGroup(conditions[groupIndex - 1].id, {
                        groupOperator: value as "AND" | "OR",
                      })
                    }
                    placeholder="AND"
                    className="text-sm"
                  />
                </div>
              )}

              {/* Removed "Type: Rule" selection - all groups are rules by default */}

              {group.conditionType === "rule" && (
                <>
                  <div className="w-20">
                    <HeadlessSelect
                      options={[
                        { value: "AND", label: "AND" },
                        { value: "OR", label: "OR" },
                      ]}
                      value={group.operator}
                      onChange={(value) =>
                        updateConditionGroup(group.id, {
                          operator: value as "AND" | "OR",
                        })
                      }
                      placeholder="AND"
                      className="text-sm"
                    />
                  </div>
                  <span className="text-sm text-gray-600">
                    {group.conditions.length} condition
                    {group.conditions.length !== 1 ? "s" : ""}
                  </span>
                </>
              )}
            </div>
            <button
              type="button"
              onClick={() => removeConditionGroup(group.id)}
              className="p-1 text-red-600 hover:text-red-700 hover:bg-red-100 rounded transition-colors"
              title="Remove Group"
            >
              <Trash2 className="w-4 h-4" />
            </button>
          </div>

          {/* Condition Content */}
          {group.conditionType === "rule" && (
            <div className="space-y-3">
              {group.conditions.map((condition, conditionIndex) => (
                <div
                  key={condition.id}
                  className="flex items-center space-x-3 bg-white p-3 rounded border"
                >
                  {conditionIndex > 0 && (
                    <span
                      className={`px-2 py-1 bg-[${color.primary.accent}]/10 text-[${color.primary.accent}] text-xs font-medium rounded`}
                    >
                      {group.operator}
                    </span>
                  )}

                  {/* Category Selection */}
                  <div className="min-w-[180px]">
                    <HeadlessSelect
                      options={categories.map((cat) => ({
                        value: cat.id.toString(),
                        label: cat.name,
                      }))}
                      value={condition.category?.toString() || ""}
                      onChange={(value) => {
                        const categoryId = parseInt(value as string);
                        // Get fields for selected category
                        const selectedCategory = categories.find(c => c.id === categoryId);
                        const categoryFields = selectedCategory?.fields || [];
                        const firstField = categoryFields.length > 0 ? categoryFields[0] : null;
                        
                        updateCondition(group.id, condition.id, {
                          category: categoryId,
                          field: firstField ? firstField.field_value : "",
                          field_id: firstField?.id,
                          operator: "equals",
                          operator_id: firstField?.operators[0]?.id,
                          value: "",
                        });
                      }}
                      placeholder="Select type"
                      className="text-sm"
                    />
                  </div>

                  {/* Field Selection - Filtered by category */}
                  <div className="min-w-[200px]">
                    <HeadlessSelect
                      options={(() => {
                        // Get fields for selected category
                        if (condition.category) {
                          const selectedCategory = categories.find(c => c.id === condition.category);
                          const fieldsToShow = selectedCategory?.fields || [];
                          return fieldsToShow.map((field) => ({
                            value: field.field_value,
                            label: field.field_name,
                          }));
                        }
                        
                        // Fallback to all fields
                        const fieldsToShow = allFields.length > 0 ? allFields : SEGMENT_FIELDS;
                        return fieldsToShow.map((field) => ({
                          value:
                            "field_value" in field
                              ? field.field_value
                              : field.key,
                          label:
                            "field_name" in field
                              ? field.field_name
                              : field.label,
                        }));
                      })()}
                      value={condition.field}
                      onChange={(value) => {
                        const fieldType = getFieldType(value as string);
                        const availableOperators = getAvailableOperators(
                          value as string
                        );

                        // Get backend field to extract IDs
                        const backendField = getFieldByValue(value as string);
                        const firstOperator = backendField?.operators[0];

                        // Map first operator symbol to our internal format
                        const symbolMap: Record<string, string> = {
                          "=": "equals",
                          "!=": "not_equals",
                          ">": "greater_than",
                          "<": "less_than",
                          IN: "in",
                          "NOT IN": "not_in",
                          LIKE: "contains",
                          "NOT LIKE": "not_contains",
                        };
                        const mappedOperator = firstOperator
                          ? symbolMap[firstOperator.symbol] ||
                            firstOperator.label
                          : availableOperators[0];

                        updateCondition(group.id, condition.id, {
                          field: value as string,
                          field_id: backendField?.id,
                          operator: mappedOperator as
                            | "equals"
                            | "not_equals"
                            | "contains"
                            | "not_contains"
                            | "greater_than"
                            | "less_than"
                            | "in"
                            | "not_in",
                          operator_id: firstOperator?.id,
                          type: fieldType,
                          value: fieldType === "number" ? 0 : "",
                        });
                      }}
                      placeholder="Select field"
                      className="text-sm"
                    />
                  </div>

                  {/* Operator Selection */}
                  <div className="min-w-[120px]">
                    <HeadlessSelect
                      options={(() => {
                        const backendField = getFieldByValue(condition.field);
                        if (backendField && backendField.operators.length > 0) {
                          return backendField.operators.map((op) => {
                            const symbolMap: Record<string, string> = {
                              "=": "equals",
                              "!=": "not_equals",
                              ">": "greater_than",
                              "<": "less_than",
                              IN: "in",
                              "NOT IN": "not_in",
                              LIKE: "contains",
                              "NOT LIKE": "not_contains",
                            };
                            const mappedOp = symbolMap[op.symbol] || op.label;
                            return {
                              value: `${mappedOp}|${op.id}`, // Store both operator name and ID
                              label:
                                op.label.charAt(0).toUpperCase() +
                                op.label.slice(1),
                            };
                          });
                        }
                        // Fallback to hardcoded operators
                        return getAvailableOperators(condition.field).map(
                          (op) => ({
                            value: `${op}|`,
                            label: OPERATOR_LABELS[op],
                          })
                        );
                      })()}
                      value={
                        condition.operator_id
                          ? `${condition.operator}|${condition.operator_id}`
                          : `${condition.operator}|`
                      }
                      onChange={(value) => {
                        const [operator, operatorId] = (value as string).split(
                          "|"
                        );
                        updateCondition(group.id, condition.id, {
                          operator: operator as
                            | "equals"
                            | "not_equals"
                            | "contains"
                            | "not_contains"
                            | "greater_than"
                            | "less_than"
                            | "in"
                            | "not_in",
                          operator_id: operatorId
                            ? parseInt(operatorId)
                            : undefined,
                        });
                      }}
                      placeholder="Select operator"
                      className="text-sm"
                    />
                  </div>

                  {/* Value Input */}
                  {renderConditionValue(group.id, condition)}

                  {/* Remove Condition */}
                  <button
                    type="button"
                    onClick={() => removeCondition(group.id, condition.id)}
                    className="p-1 text-red-600 hover:text-red-700 hover:bg-red-100 rounded transition-colors"
                    title="Remove Condition"
                    disabled={group.conditions.length === 1}
                  >
                    <Trash2 className="w-4 h-4" />
                  </button>
                </div>
              ))}
            </div>
          )}

          {/* List Upload Component */}
          {group.conditionType === "list" && (
            <ListUpload
              listData={group.listData}
              onListDataChange={(listData) =>
                updateConditionGroup(group.id, { listData })
              }
            />
          )}

          {/* Segments Selection */}
          {group.conditionType === "segments" && (
            <div
              className="p-4 rounded-md border border-gray-200"
              style={{ backgroundColor: `${color.primary.accent}10` }}
            >
              <h4 className={`font-medium ${tw.textPrimary} mb-2`}>
                Select Segments
              </h4>
              <p className={`text-sm ${tw.textSecondary} mb-3`}>
                Choose existing segments to include in this condition group.
              </p>
              <select className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none">
                <option value="">Select a segment...</option>
                {/* This would be populated with actual segments from the backend */}
              </select>
            </div>
          )}

          {/* 360 Profile */}
          {group.conditionType === "360" && (
            <div
              className="p-4 rounded-md border border-gray-200"
              style={{ backgroundColor: `${color.primary.accent}10` }}
            >
              <h4 className={`font-medium ${tw.textPrimary} mb-2`}>
                360 Customer Profile
              </h4>
              <p className={`text-sm ${tw.textSecondary} mb-3`}>
                Configure conditions based on comprehensive customer profile
                data.
              </p>

              <div className="space-y-3">
                {(group.profileConditions || []).length === 0 ? (
                  <div className="text-center py-4">
                    <p className="text-gray-500 mb-3">
                      No profile conditions defined yet
                    </p>
                    <button
                      type="button"
                      onClick={() => addProfileCondition(group.id)}
                      className="inline-flex items-center px-3 py-2 text-sm text-white rounded-md transition-colors"
                      style={{ backgroundColor: color.primary.action }}
                    >
                      <Plus className="w-4 h-4 mr-2" />
                      Add Profile Condition
                    </button>
                  </div>
                ) : (
                  <>
                    {group.profileConditions?.map(
                      (condition, conditionIndex) => (
                        <div
                          key={condition.id}
                          className="flex items-center space-x-3 bg-white p-3 rounded border"
                        >
                          {conditionIndex > 0 && (
                            <span
                              className="px-2 py-1 text-xs font-medium rounded"
                              style={{
                                backgroundColor: `${color.primary.accent}20`,
                                color: color.primary.accent,
                              }}
                            >
                              AND
                            </span>
                          )}

                          {/* Profile Field Selection */}
                          <select
                            value={condition.field}
                            onChange={(e) => {
                              const fieldType = getFieldType(
                                e.target.value,
                                true
                              );
                              const availableOperators = getAvailableOperators(
                                e.target.value,
                                true
                              );
                              updateProfileCondition(group.id, condition.id, {
                                field: e.target.value,
                                operator: availableOperators[0] as
                                  | "equals"
                                  | "not_equals"
                                  | "contains"
                                  | "not_contains"
                                  | "greater_than"
                                  | "less_than"
                                  | "in"
                                  | "not_in",
                                type: fieldType,
                                value: fieldType === "number" ? 0 : "",
                              });
                            }}
                            className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none min-w-[200px]"
                            style={{
                              borderColor: tw.borderDefault,
                            }}
                          >
                            {PROFILE_360_FIELDS.map((field) => (
                              <option key={field.key} value={field.key}>
                                {field.label}
                              </option>
                            ))}
                          </select>

                          {/* Operator Selection */}
                          <select
                            value={condition.operator}
                            onChange={(e) =>
                              updateProfileCondition(group.id, condition.id, {
                                operator: e.target.value as
                                  | "equals"
                                  | "not_equals"
                                  | "contains"
                                  | "not_contains"
                                  | "greater_than"
                                  | "less_than"
                                  | "in"
                                  | "not_in",
                              })
                            }
                            className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none"
                            style={{
                              borderColor: tw.borderDefault,
                            }}
                          >
                            {getAvailableOperators(condition.field, true).map(
                              (op) => (
                                <option key={op} value={op}>
                                  {OPERATOR_LABELS[op]}
                                </option>
                              )
                            )}
                          </select>

                          {/* Value Input */}
                          {renderConditionValue(group.id, condition, true)}

                          {/* Remove Condition */}
                          <button
                            type="button"
                            onClick={() =>
                              removeProfileCondition(group.id, condition.id)
                            }
                            className="p-1 text-red-600 hover:text-red-700 hover:bg-red-100 rounded transition-colors"
                            title="Remove Condition"
                            disabled={group.profileConditions?.length === 1}
                          >
                            <Trash2 className="w-4 h-4" />
                          </button>
                        </div>
                      )
                    )}

                    {/* Add Profile Condition Button */}
                    <button
                      type="button"
                      onClick={() => addProfileCondition(group.id)}
                      className="inline-flex items-center px-3 py-2 text-sm text-white rounded-md transition-colors"
                      style={{
                        backgroundColor: color.primary.action,
                      }}
                    >
                      <Plus className="w-4 h-4 mr-2" />
                      Add Profile Condition
                    </button>
                  </>
                )}
              </div>
            </div>
          )}

          {/* Add Condition Button - Only show for rule type */}
          {group.conditionType === "rule" && (
            <button
              type="button"
              onClick={() => addCondition(group.id)}
              className="mt-3 inline-flex items-center px-3 py-2 text-sm text-white rounded-md transition-colors"
              style={{
                backgroundColor: color.primary.action,
              }}
            >
              <Plus className="w-4 h-4 mr-2" />
              Add Condition
            </button>
          )}
        </div>
      ))}

      {/* Add Group Button */}
      <button
        type="button"
        onClick={addConditionGroup}
        className="inline-flex items-center px-4 py-2 text-sm text-white rounded-md transition-colors"
        style={{ backgroundColor: color.primary.action }}
      >
        <Plus className="w-4 h-4 mr-2" />
        Add Condition Group
      </button>
    </div>
  );
}
